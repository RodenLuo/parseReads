#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Created on Fri Nov 14 10:38:07 2014
Modified Apr 21, 2015

@author: Chi Zhang
@email: roy.chizhang@gmail.com

This script would read in fastq files. The fastq file should already have been trimmed by quality filtering.
Afterwards it'll match each read to the pattern defined by the input file defined by -s flag, in the format of:
sequence 1
.......
sequence 2
.......

The output of this program will be a json file whose name is specified by the -o/--output flag. It will be a list that harbors a few lists inside. 

The first sub-list contains boolean values, and each member of the list corresponds to the corresponding read from the input fastq file (specified by -i/--inputfile flag). The boolean values indicate whether the specific corresponding read (from the fastq file) matched the pattern specified by the stringfile (spedified by -s/--stringfile flag).

The rest of the sub-lists contain sequences parsed from the reads that matched the sequence pattern (the first of these will be CDR1, the second will be CDR2 .......). The indexes within the sublist correspond to the sequence within the matched reads (eg: the 0th element of CDR1 sub-list and the 0th element of CDR2 sub-list are CDR sequences parsed from the first (and the same) sequence read that matched the sequence pattern).

"""
import sys, getopt
import numpy as np
import re
import pandas as pd

helperMessage = "HELPER INFO:\n\n\
        ParsePattern would read in illumina style fastq files and match the sequences with sequence patterns defined in the \
stringFile input. The fastq file should already have been trimmed by quality filtering, and no quality filtering is \
performed by ParsePattern.\n" + "ParsePattern matches each read to the pattern defined by the input file defined by -s \
flag, in the format of:\n" + "sequence 1\n.......\nsequence 2\n.......\nPlease note that this pattern should not be \
changed for recognition!\nParsePattern prints to the screen the regex string used for pattern matching, and # of reads \
that match or does not match to the regex pattern.\nThe output file generated by ParsePattern (specified by -o) is a csv \
file of the # coverage of each matched sequence (in between sequence1 and sequence2). If the pattern has multiple \
sequences specified (eg: sequence 1 ..... sequence 2 ..... sequence 3 .....), it means multiple gaps are present, and \
multiple output files will be generated, each corresponding to the different gaps between the sequences specified.\
\n\nusage: ParsePattern -i <inputfile name> -s <stringfile name> -o <outputfile name> "
#==============================================================================
# getSeqAndQua function takes inputFileHandle and returns an iterator object of a tuple,
# the tuple contains a string for the sequence, and a string for the qualtity score. 
#==============================================================================
def getSeqAndQua(inputFile):
    firstRead = inputFile.readline()    
    while firstRead != '':
        while firstRead[0] != '@':
            firstRead = inputFile.readline()
        sequence = inputFile.readline()
        inputFile.readline()
        quality = inputFile.readline()
        yield (sequence, quality)
        firstRead = inputFile.readline()  
        
#==============================================================================
# getQScoreTable function generates a dictionary that describes the Q scores of \
# each symbol 
#==============================================================================
def getQScore(ascii):
    if ascii >= '!' and ascii <= 'J':
        return int(ord(ascii) - 33)
        
#==============================================================================
# get_options function get the analysis options from command line
# here the startBase is by default 0, and endBase is by default 299 (totally 300
# basecalls)

# Return: filehandle of the file that contains the sequences of conserved region
# sequences
#==============================================================================
def get_options(argv):
    try:
        opts, args = getopt.getopt(argv, "hs:i:o:", ["help", "inputfile=", "inputFile=" "stringfile=", "stringFile=", "output="])
    except getopt.GetoptError:
        print helperMessage
        sys.exit(2)

    stringFile = ''   
    outputFile = ''
    inputFile = ''
    for opt, arg in opts:
        if opt in ('-h', '--help'):
	    sys.exit( helperMessage )
        elif opt in ('-s', '--stringfile', '--stringFile'):
            stringFile = arg
	elif opt in ('-i', '--inputfile', '--inputFile'):
	    inputFile = arg
	elif opt in ('-o', '--output'):
	    outputFile = arg
    
    return (stringFile, outputFile, inputFile)
            
#==============================================================================
# getConservedSeq function takes a file handle, and returns a list of patterns
# indicated in the file. the file format is:
#     sequence 1
#     .............
#     sequence 2
#     .............
#     sequence 3
#     .............
#==============================================================================
def getConservedSeq(stringFile):
    conservedSeq = stringFile.read()
    pattern = '(?<=sequence\s\d\s)\w+'
    return re.findall(pattern, conservedSeq)
    
def derivePattern(conservedSeq):
    numConserved = len(conservedSeq)
    pattern = ''
    if numConserved > 1:
        for i in range(numConserved - 1):
            pattern += conservedSeq[i]
            pattern += '(?P<PATTERN%d>\w+)' %(i+1)
        pattern += conservedSeq[numConserved -1]
    return (pattern, i+1)

#==============================================================================
# matchPattern function takes a string sequence, a string of patternString, and  an outputFile handle. It compares the sequence to the patternString, and if the sequence matches, the function will write the sequence to the outputFile, with 
# an integer index that separates the different reads
#==============================================================================
def matchPattern(sequence, patternString, CDRmatch):
    pattern = re.compile(patternString)
    matchResult = pattern.search(sequence)
    if matchResult:
	if len(CDRmatch) == 1:
		CDRmatch[0].append(matchResult.groups())
	else:
		CDRmatch[0].append(True)
		for PATTERN in range(len(CDRmatch)-1):
			matchedSeq = matchResult.groups()[PATTERN]
			CDRmatch[PATTERN + 1].append(matchedSeq)
	return True
    else:
	CDRmatch[0].append(False)
	return False
  
def main():
    stringFile, outputFile, inputFile = get_options(sys.argv[1:])
    
    stringFile = open(stringFile, 'r')
    # Here keep outputFile as a string
    inputFile = open(inputFile, 'r')
    
    
    inputFile = inputFile.read().rsplit('\n')
    conservedSeq = getConservedSeq(stringFile)
    patternString, numCDR = derivePattern(conservedSeq)
    print ( patternString )
    CDRmatch = []
    for i in range(numCDR + 1):
        CDRmatch.append([])
    matchReadCount = 0
    unmatchReadCount = 0
    for seq in inputFile[1::4]:
#        sequenceToMatch = seqAndQuality[0]
        if matchPattern(seq, patternString, CDRmatch):
	    matchReadCount += 1
	else:
            unmatchReadCount += 1
    print ('Matched reads: ' + str(matchReadCount))
    print ('Unmatched reads: ' + str(unmatchReadCount) + '\n')

    sequences = pd.DataFrame ( CDRmatch [ 1 : ] ) 
    sequences = sequences.T
    cols = sequences.columns
    if len ( cols ) == 1 :
        sequences [ cols [ 0 ] ] . value_counts() . to_csv ( outputFile )
    else:
        for i in range ( len ( cols )):
            sequences [ cols [ i ] ] . value_counts () . to_csv (outputFile + 
                    "pattern" + str(i) + ".csv" )

if __name__ == '__main__':
    try:
        main()
    except IOError:
        print helperMessage 
